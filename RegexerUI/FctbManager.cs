using FastColoredTextBoxNS;
using Regexer;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows.Forms;
using Range = FastColoredTextBoxNS.Range;

namespace RegexerUI
{
    public class FctbManager
    {
        public static readonly Brush BaseBrush = Brushes.Gainsboro;
        public static readonly Brush BaseBrushLight = new SolidBrush(Color.FromArgb(235, 235, 235));
        public static readonly Brush TransparentBrush = new SolidBrush(Color.Transparent);
        public static readonly SolidBrush MatchPositionBrush = new SolidBrush(Color.DarkGray);
        public const StyleIndex BaseStyleIndex = StyleIndex.Style0;
        public const StyleIndex ErrorStyleIndex = StyleIndex.Style3;
        private readonly TextStyle BaseStyle = new(null, BaseBrush, FontStyle.Bold);
        private static readonly TextStyle[] IndividualMatchStyles = {
            //Generated by Claude Haiku 4.5
            new (new SolidBrush(Color.FromArgb(0, 0, 139)), BaseBrush, FontStyle.Bold),        // Dark Blue
            new (new SolidBrush(Color.FromArgb(0, 100, 0)), BaseBrush, FontStyle.Bold),        // Dark Green
            new (new SolidBrush(Color.FromArgb(192, 0, 0)), BaseBrush, FontStyle.Bold),        // Dark Red
            new (new SolidBrush(Color.FromArgb(184, 134, 11)), BaseBrush, FontStyle.Bold),     // Dark Goldenrod
            new (new SolidBrush(Color.FromArgb(128, 0, 128)), BaseBrush, FontStyle.Bold),      // Purple
            new (new SolidBrush(Color.FromArgb(139, 69, 19)), BaseBrush, FontStyle.Bold),      // Saddle Brown
            new (new SolidBrush(Color.FromArgb(0, 128, 128)), BaseBrush, FontStyle.Bold),      // Teal
            new (new SolidBrush(Color.FromArgb(105, 105, 105)), BaseBrush, FontStyle.Bold),    // Dim Gray
            new (new SolidBrush(Color.FromArgb(139, 0, 139)), BaseBrush, FontStyle.Bold),      // Dark Magenta
            new (new SolidBrush(Color.FromArgb(85, 107, 47)), BaseBrush, FontStyle.Bold),      // Dark Olive Green
            new (new SolidBrush(Color.FromArgb(47, 79, 79)), BaseBrush, FontStyle.Bold),       // Dark Slate Gray
            new (new SolidBrush(Color.FromArgb(25, 25, 112)), BaseBrush, FontStyle.Bold),      // Midnight Blue
            new (new SolidBrush(Color.FromArgb(178, 34, 34)), BaseBrush, FontStyle.Bold),      // Firebrick
            new (new SolidBrush(Color.FromArgb(75, 0, 130)), BaseBrush, FontStyle.Bold),       // Indigo
            new (new SolidBrush(Color.FromArgb(128, 0, 0)), BaseBrush, FontStyle.Bold),        // Maroon

            //The below have been excluded because FastColoredTextBox only supports 16 styles for each textbox

            //new (new SolidBrush(Color.FromArgb(0, 128, 64)), BaseBrush, FontStyle.Bold),       // Dark Cyan-Green
            //new (new SolidBrush(Color.FromArgb(220, 20, 60)), BaseBrush, FontStyle.Bold),      // Crimson
            //new (new SolidBrush(Color.FromArgb(102, 51, 153)), BaseBrush, FontStyle.Bold),     // Dark Purple
            //new (new SolidBrush(Color.FromArgb(102, 102, 0)), BaseBrush, FontStyle.Bold),      // Dark Olive
            //new (new SolidBrush(Color.FromArgb(34, 139, 34)), BaseBrush, FontStyle.Bold),      // Forest Green
        };

        private static readonly string SubMatchPattern = @$"(?<{Style.BaseLight}>(?>\[\[(?<Open>)|(?<-Open>\]\])|\[(?!\[)|\](?!\])|[^\[\]])*(?(Open)(?!)))";
        private readonly string[] _patterns =
        {
            @$"\[\[(?<{Style.Label}>\w+)(?:(?<{Style.Separator}>\|)(?<{Style.KeyLetter}>(ml|[wdsgol]+)))?\]\]",
            @$"\[\[(?<{Style.Label}>\w+)?(?<{Style.Regex}>\{{[^\r\n]+?\}})\]\]",
            @$"\[\[(?:(?<{Style.Label}>\w+)(?<{Style.Separator}>\|))?(?<{Style.KeyLetter}>u)(?<{Style.Separator}>\|)(?<{Style.BaseLight}>[^\r\n]+)\]\]",
            @$"\[\[(?:(?<{Style.Label}>\w+)(?<{Style.Separator}>\|))?(?<{Style.KeyLetter}>m)(?<{Style.Separator}>\|)(?<{Style.Regex}>\{{[^\r\n]+?\}})(?:(?<{Style.Separator}>\|){SubMatchPattern})?\]\]"
        };
        private readonly string[] _replacePatterns =
        {
            @$"\[\[(?<{Style.Label}>\w+)(?:(?<{Style.Separator}>\|)(?<{Style.KeyLetter}>ml))?\]\]",
            @$"\[\[(?<{Style.Label}>\w+)(?<{Style.Separator}>\|)(?<{Style.KeyLetter}>c)(?<{Style.Separator}>:)(?<{Style.KeyLetter}>u|l|s|fu|fl)\]\]",
            @$"\[\[(?<{Style.Label}>\w+)(?<{Style.Separator}>\|)(?<{Style.KeyLetter}>o)(?<{Style.Separator}>:){SubMatchPattern}\]\]",
            @$"\[\[(?<{Style.Label}>\w+)(?<{Style.Separator}>\|)(?<{Style.KeyLetter}>u)(?:(?<{Style.Separator}>:){SubMatchPattern})?\]\]",
            @$"\[\[(?<{Style.Label}>\w+)(?<{Style.Separator}>\|)(?<{Style.KeyLetter}>m)(?:(?<{Style.Separator}>:)(?<{Style.Regex}>[^\r\n]+?)(?:(?<{Style.Separator}>:){SubMatchPattern})?)?\]\]",
            @$"\[\[(?<{Style.Label}>\w+)(?<{Style.Separator}>\|)(?<{Style.KeyLetter}>d)(?<{Style.Separator}>:)(?<{Style.KeyLetter}>\d+|[\di+*/%-]+)(?:(?<{Style.Separator}>:)(?<{Style.Regex}>[^\r\n]+?))?\]\]",
            @$"\[\[(?<{Style.Label}>\w+)(?<{Style.Separator}>\|)(?<{Style.KeyLetter}>e)(?<{Style.Separator}>:)(?<{Style.KeyLetter}>\d+|[\dim()+*/%-]+)\]\]",
        };

        private readonly Regex _newLineRegex = new("<ml>");
        private readonly Dictionary<Style, StyleIndex> _allStyles = new();
        private readonly HashSet<string> _patternLabels = new();
        private readonly HashSet<string> _patternUmLabels = new();
        private readonly Dictionary<string, (StyleIndex, SolidBrush)> _labelStyles = new();
        private readonly List<int> _stylingOrder = new();

        public void SetupTextBoxStyles(FastColoredTextBox inputTextBox, FastColoredTextBox outputTextBox)
        {
            inputTextBox.AddStyle(BaseStyle);
            outputTextBox.AddStyle(BaseStyle);
            foreach (var individualMatchStyle in IndividualMatchStyles)
            {
                inputTextBox.AddStyle(individualMatchStyle);
                outputTextBox.AddStyle(individualMatchStyle);
            }
        }

        public void SetupPatternTextBoxes(FastColoredTextBox findTextBox, FastColoredTextBox replaceTextBox)
        {
            InitializeStyles(findTextBox, true);
            InitializeStyles(replaceTextBox, false);
            InitializePopup(findTextBox, false);
            InitializePopup(replaceTextBox, true);
            return;

            void InitializeStyles(FastColoredTextBox textBox, bool first)
            {
                textBox.AddStyle(BaseStyle);
                foreach (Style style in Enum.GetValues(typeof(Style)))
                {
                    var textStyle = style switch
                    {
                        Style.Label => BaseStyle,
                        Style.Separator => new TextStyle(Brushes.BlueViolet, BaseBrush, FontStyle.Bold),
                        Style.KeyLetter => new TextStyle(Brushes.CornflowerBlue, BaseBrush, FontStyle.Bold),
                        Style.Regex => new TextStyle(Brushes.Brown, BaseBrush, FontStyle.Bold),
                        Style.BaseLight => new TextStyle(null, BaseBrushLight, FontStyle.Regular),
                        _ => throw new ArgumentOutOfRangeException()
                    };
                    var styleIndex = Range.ToStyleIndex(textBox.AddStyle(textStyle));
                    if(first) _allStyles.Add(style, styleIndex);
                }
            }

            void InitializePopup(FastColoredTextBox textBox, bool isReplaceText)
            {
                var autocomplete = new AutocompleteMenu(textBox);
                autocomplete.SearchPattern = @"[^\r\n]";
                autocomplete.AlwaysShowTooltip = true;
                autocomplete.SelectedColor = Color.LightBlue;
                //const int autoCompleteWidth = 250;
                //autocomplete.Items.MaximumSize = autocomplete.Items.MaximumSize with { Width = autoCompleteWidth };
                //autocomplete.Items.Width = autoCompleteWidth;
                //autocomplete.MinFragmentLength = 0;
                autocomplete.ToolTipDuration = 0;
                autocomplete.Items.NoSpacingForIcons = true;
                autocomplete.Items.AutoWidth = true;
                autocomplete.Items.UseSolidBrushForSelected = true;
                autocomplete.Items.ReShowMenuAfterSelected = true;
                autocomplete.MaxTooltipSize = new Size(300, 1000);
                autocomplete.Items.SetAutocompleteItems(new Intellisense(textBox, autocomplete, isReplaceText, () => _patternLabels.OrderBy(l => l)));
            }
        }

        public void HighlightPatternSyntax(FastColoredTextBox textBox, Range range, bool isReplaceText, bool isNested = false)
        {
            if (!isNested)
            {
                foreach (var styleIndex in _allStyles.Values)
                {
                    range.ClearStyle(styleIndex);
                }
                if (!isReplaceText)
                {
                    _patternLabels.Clear();
                    _patternUmLabels.Clear();
                }
            }
            var start = range.Start.iChar;
            for (var i = 0; i < range.Start.iLine; i++)
            {
                start += textBox.GetLine(i).Length + "\r\n".Length;
            }
            var patterns = isReplaceText ? _replacePatterns : _patterns;
            foreach (var pattern in patterns)
            {
                var matches = Regex.Matches(range.Text, pattern);
                if (!matches.Any()) continue;
                foreach (Match match in matches)
                {
                    textBox.GetRange(start + match.Index, start + match.Index + match.Length).SetStyle(BaseStyleIndex);
                    foreach (var style in _allStyles.Keys)
                    {
                        var group = match.Groups[style.ToString()];
                        if (group.Success)
                        {
                            switch (style)
                            {
                                case Style.Label:
                                    if (isReplaceText) break;
                                    if (_patternLabels.Add(group.Value))
                                    {
                                        if (match.Groups[nameof(Style.KeyLetter)].Value is "u" or "m")
                                            _patternUmLabels.Add(group.Value);
                                    }
                                    break;
                                case Style.Separator:
                                case Style.KeyLetter:
                                    foreach (Capture capture in group.Captures)
                                    {
                                        textBox.GetRange(start + capture.Index, start + capture.Index + capture.Length).SetStyle(_allStyles[style]);
                                    }
                                    break;
                                case Style.Regex:
                                    textBox.GetRange(start + group.Index, start + group.Index + group.Length).SetStyle(_allStyles[style]);
                                    textBox.GetRange(start + group.Index, start + group.Index + group.Length).SetStyle(_allStyles[Style.KeyLetter], _newLineRegex);
                                    break;
                                case Style.BaseLight:
                                    var r = textBox.GetRange(start + group.Index, start + group.Index + group.Length);
                                    r.SetStyle(_allStyles[style]);
                                    HighlightPatternSyntax(textBox, r, isReplaceText, true);
                                    break;
                                default:
                                    throw new ArgumentOutOfRangeException();
                            }
                        }
                    }
                }
            }
        }

        public void StyleMatches(FastColoredTextBox inputTextbox, FastColoredTextBox outputTextbox, DataGridView inputGrid, DataGridView outputGrid, RegexerResult result)
        {
            _labelStyles.Clear();
            _stylingOrder.Clear();

            for (var i = 0; i < result.Matches[0].InputMatch.IndividualMatches.Count; i++)
            {
                if (i == IndividualMatchStyles.Length) i = 0;
                var match = result.Matches[0].InputMatch.IndividualMatches[i];
                inputGrid.Columns.Add(match.Label, match.Label);
                outputGrid.Columns.Add(match.Label, match.Label);
                var brush = (SolidBrush)IndividualMatchStyles[i].ForeBrush;
                inputGrid.Columns[i].HeaderCell.Style.ForeColor = brush.Color;
                outputGrid.Columns[i].HeaderCell.Style.ForeColor = brush.Color;
                _labelStyles.Add(match.Label, (Range.ToStyleIndex(i + 1), brush));
                if(_patternUmLabels.Contains(match.Label)) _stylingOrder.Insert(0, i);
                else _stylingOrder.Add(i);
            }

            foreach (var matchPair in result.Matches)
            {
                Range matchRange;
                StyleIndex styleIndex;
                SolidBrush brush;
                if(matchPair.InputMatch.IndividualMatches.Count == 0) continue;
                var dataGridRow = inputGrid.Rows[inputGrid.Rows.Add()];
                dataGridRow.HeaderCell.Value = (dataGridRow.Index + 1).ToString();
                foreach (var index in _stylingOrder)
                {
                    var individualMatch = matchPair.InputMatch.IndividualMatches[index];
                    (styleIndex, brush) = _labelStyles[individualMatch.Label];
                    dataGridRow.Cells[individualMatch.Label].Value = new CellMatchData(individualMatch.Captures, brush);
                    foreach (var capture in individualMatch.Captures)
                    {
                        matchRange = inputTextbox.GetRange(capture.Index, capture.Index + capture.Length);
                        matchRange.SetStyle(styleIndex);
                    }
                }

                if (matchPair.OutputMatch != null)
                {
                    dataGridRow = outputGrid.Rows[outputGrid.Rows.Add()];
                    dataGridRow.HeaderCell.Value = (dataGridRow.Index + 1).ToString();
                    foreach (var index in _stylingOrder)
                    {
                        var individualMatch = matchPair.OutputMatch.IndividualMatches[index];
                        (styleIndex, brush) = _labelStyles[individualMatch.Label];
                        dataGridRow.Cells[individualMatch.Label].Value = new CellMatchData(individualMatch.Captures, brush);
                        foreach (var capture in individualMatch.Captures)
                        {
                            matchRange = outputTextbox.GetRange(capture.Index, capture.Index + capture.Length);
                            matchRange.SetStyle(styleIndex);
                        }
                    }
                }
            }
        }

        public void ClearMatchStyles(FastColoredTextBox inputTextbox, FastColoredTextBox outputTextbox)
        {
            inputTextbox.Range.ClearStyle(BaseStyleIndex);
            outputTextbox.Range.ClearStyle(BaseStyleIndex);
            for (var i = 0; i < IndividualMatchStyles.Length; i++)
            {
                inputTextbox.Range.ClearStyle(Range.ToStyleIndex(i + 1)); //+1 because BaseStyle is the first
                outputTextbox.Range.ClearStyle(Range.ToStyleIndex(i + 1));
            }
        }

        private enum Style{ Label, Separator, KeyLetter, Regex, BaseLight }

        public class CellMatchData
        {
            public List<MatchData> MatchDataCaptures { get; set; }
            public Brush TextBrush { get; set; }

            public CellMatchData(List<MatchData> matchDataCaptures, Brush textBrush)
            {
                MatchDataCaptures = matchDataCaptures;
                TextBrush = textBrush;
            }

            public static string PositionString(MatchData matchData) =>
                matchData.Length == 0 ? string.Empty : $" ({matchData.Index} - {matchData.Index + matchData.Length})";

            private string? _cachedToString;
            public override string ToString()
            {
                return _cachedToString ??=
                    string.Join('\n', MatchDataCaptures.Select(m => $"{m.Text}{PositionString(m)}"));
            }
        }
    }
}
