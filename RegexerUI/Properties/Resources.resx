<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Testing" xml:space="preserve">
    <value>Testing</value>
  </data>
  <data name="UnorderedMatchTitle" xml:space="preserve">
    <value>Unordered match</value>
  </data>
  <data name="UnorderedMatchText" xml:space="preserve">
    <value>Use this to match multiple phrases or lines that may appear in any order</value>
  </data>
  <data name="MultipleMatchTitle" xml:space="preserve">
    <value>Multi match</value>
  </data>
  <data name="MultipleMatchText" xml:space="preserve">
    <value>Use this to match multiple phrases or lines separated by the specified separator</value>
  </data>
  <data name="MultipleMatchSeparatorTitle" xml:space="preserve">
    <value>Multi match separator</value>
  </data>
  <data name="MultipleMatchSeparatorText" xml:space="preserve">
    <value>The text that separates each occurrence. Can be a regex pattern</value>
  </data>
  <data name="MultipleMatchMatchTitle" xml:space="preserve">
    <value>Multi match phrase/line</value>
  </data>
  <data name="MultipleMatchMatchText" xml:space="preserve">
    <value>This pattern matches each occurrence. If omitted, will match whatever appears between the separators</value>
  </data>
  <data name="CustomRegexTitle" xml:space="preserve">
    <value>Custom regex</value>
  </data>
  <data name="CustomRegexText" xml:space="preserve">
    <value>Match a custom regex pattern</value>
  </data>
  <data name="ModifierTitle" xml:space="preserve">
    <value>Match modifiers (restrictors and quantifiers)</value>
  </data>
  <data name="ModifierText" xml:space="preserve">
    <value>Restrict your matches to digits, alphanumeric characters e.t.c for precision or specify how much stuff should be matched</value>
  </data>
  <data name="CustomRegexWordTitle" xml:space="preserve">
    <value>Word restriction (\w)</value>
  </data>
  <data name="CustomRegexWordText" xml:space="preserve">
    <value>Restrict the match to underscore and alphanumeric characters (_, a-z, A - Z)</value>
  </data>
  <data name="CustomRegexDigitTitle" xml:space="preserve">
    <value>Digit restriction (\d)</value>
  </data>
  <data name="CustomRegexDigitText" xml:space="preserve">
    <value>Restrict the match to digits (0 - 9)</value>
  </data>
  <data name="CustomRegexSpaceTitle" xml:space="preserve">
    <value>Whitespace restriction (\s)</value>
  </data>
  <data name="CustomRegexSpaceText" xml:space="preserve">
    <value>Restrict the match to whitespace (tabs, spaces)</value>
  </data>
  <data name="CustomRegexGreedyTitle" xml:space="preserve">
    <value>Greedy quantifier (+)</value>
  </data>
  <data name="CustomRegexGreedyText" xml:space="preserve">
    <value>Match the most characters that can fit the pattern. It can go all the way to the end of the line, but can't include line breaks.</value>
  </data>
  <data name="CustomRegexOptionalTitle" xml:space="preserve">
    <value>Optional quantifier (?)</value>
  </data>
  <data name="CustomRegexOptionalText" xml:space="preserve">
    <value>This match may or may not be present</value>
  </data>
  <data name="CustomRegexLBTitle" xml:space="preserve">
    <value>Line breaks inclusion (\r\n)</value>
  </data>
  <data name="CustomRegexLBText" xml:space="preserve">
    <value>Include line breaks in the match. This means the match can span multiple lines.</value>
  </data>
  <data name="MultiLineTitle" xml:space="preserve">
    <value>Multiline match</value>
  </data>
  <data name="MultiLineText" xml:space="preserve">
    <value>Match multiple lines that can be individually prefixed and suffixed</value>
  </data>
  <data name="ReplaceModifierTitle" xml:space="preserve">
    <value>Replace modifiers</value>
  </data>
  <data name="ReplaceModifierText" xml:space="preserve">
    <value>Replace and transform your matches</value>
  </data>
  <data name="ReplaceTitle" xml:space="preserve">
    <value>Replace appearing match</value>
  </data>
  <data name="ReplaceText" xml:space="preserve">
    <value>Replace a match with the specified text if it appears, otherwise, omit it. The specified text can contain other matches</value>
  </data>
  <data name="ReplaceMultiTitle" xml:space="preserve">
    <value>Replace multiple occurrence matches</value>
  </data>
  <data name="ReplaceMultiText" xml:space="preserve">
    <value>Replace multiple line/phrases that were matched with the |m pattern. You can change the separator, and transform each occurrence or replace them entirely</value>
  </data>
  <data name="ReplaceMultiReplaceText" xml:space="preserve">
    <value>Enter the text that will replace each match occurrence. If the match part of the |m pattern had sub-matches, you can reference them here with [[foo|m]]</value>
  </data>
  <data name="ReplaceMultiReplaceTitle" xml:space="preserve">
    <value>Replacement per match occurrence</value>
  </data>
  <data name="DuplicationTitle" xml:space="preserve">
    <value>Duplicate matches</value>
  </data>
  <data name="DuplicationText" xml:space="preserve">
    <value>Duplicate matches by specifying the amount (which can be a calculation) of duplications and the characters that separate them</value>
  </data>
  <data name="MatchIndexText" xml:space="preserve">
    <value>Use i to represent the index of the match in the expression. For example, i is 5 for the 5th match</value>
  </data>
  <data name="MatchIndexTitle" xml:space="preserve">
    <value>Index of the match</value>
  </data>
  <data name="AdditionText" xml:space="preserve">
    <value>Add</value>
  </data>
  <data name="SubtractionText" xml:space="preserve">
    <value>Subtract</value>
  </data>
  <data name="MultiplicationText" xml:space="preserve">
    <value>Multiply</value>
  </data>
  <data name="DivisionText" xml:space="preserve">
    <value>Divide</value>
  </data>
  <data name="ModuloText" xml:space="preserve">
    <value>Modulo operation. (Remainder gotten from a division)</value>
  </data>
  <data name="DuplicationSeparatorTitle" xml:space="preserve">
    <value>Duplication separator</value>
  </data>
  <data name="DuplicationSeparatorText" xml:space="preserve">
    <value>The character/text that separates each duplication</value>
  </data>
  <data name="ReplaceNumberText" xml:space="preserve">
    <value>If the match is a digit, you can replace the number with another number or the result of an expression</value>
  </data>
  <data name="ReplaceNumberTitle" xml:space="preserve">
    <value>Replace number</value>
  </data>
  <data name="MatchValueText" xml:space="preserve">
    <value>Use m to represent the original value of the match in the expression</value>
  </data>
  <data name="MatchValueTitle" xml:space="preserve">
    <value>Value of the match</value>
  </data>
  <data name="CapitalizationTitle" xml:space="preserve">
    <value>Capitalization transform</value>
  </data>
  <data name="CapitalizationText" xml:space="preserve">
    <value>Transform the match by changing the casing</value>
  </data>
  <data name="FirstUppercaseText" xml:space="preserve">
    <value>Make the first character uppercase. Keep the casing of the other characters.</value>
  </data>
  <data name="FirstLowercaseText" xml:space="preserve">
    <value>Make the first character lowercase. Keep the casing of the other characters.</value>
  </data>
  <data name="SentenceText" xml:space="preserve">
    <value>Make the first character uppercase and the other characters lowercase</value>
  </data>
  <data name="UppercaseText" xml:space="preserve">
    <value>Make all the characters uppercase</value>
  </data>
  <data name="LowercaseText" xml:space="preserve">
    <value>Make all the characters lowercase</value>
  </data>
  <data name="MultiLineRepTitle" xml:space="preserve">
    <value>Multiline transform</value>
  </data>
  <data name="MultiLineRepText" xml:space="preserve">
    <value>You can either just place this pattern to place the multiline matches as they were, or add some text before and/or after the pattern to add text to each line in the match</value>
  </data>
  <data name="AddLineBreakTitle" xml:space="preserve">
    <value>Add line break</value>
  </data>
  <data name="AddLineBreakText" xml:space="preserve">
    <value>Use &lt;ml&gt; to represent a line break (\r\n)</value>
  </data>
  <data name="CloseTagTitle" xml:space="preserve">
    <value>Close pattern tag</value>
  </data>
  <data name="CloseTagText" xml:space="preserve">
    <value>Close the tag with ]]</value>
  </data>
</root>